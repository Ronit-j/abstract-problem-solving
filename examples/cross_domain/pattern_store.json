[
  {
    "id": "pat-divide-conquer",
    "name": "Divide and Conquer",
    "description": "When a problem can be recursively decomposed into independent sub-problems of the same type, solve each sub-problem independently and combine the results.",
    "problem": {
      "id": "prob-dac",
      "name": "Recursively Decomposable Problem",
      "structure": {
        "entities": [
          {
            "id": "whole",
            "type": "collection",
            "properties": {
              "size": "n"
            }
          },
          {
            "id": "part_1",
            "type": "collection",
            "properties": {
              "size": "n/2"
            }
          },
          {
            "id": "part_2",
            "type": "collection",
            "properties": {
              "size": "n/2"
            }
          }
        ],
        "relations": [
          {
            "source": "whole",
            "target": "part_1",
            "type": "contains",
            "properties": {}
          },
          {
            "source": "whole",
            "target": "part_2",
            "type": "contains",
            "properties": {}
          }
        ]
      },
      "constraints": [
        {
          "predicate": "parts are independent",
          "over": [
            "part_1",
            "part_2"
          ],
          "type": "invariant"
        },
        {
          "predicate": "parts cover whole",
          "over": [
            "whole",
            "part_1",
            "part_2"
          ],
          "type": "invariant"
        }
      ],
      "goal": {
        "type": "transform",
        "target": "whole",
        "predicate": "whole is in solved state"
      },
      "tags": [
        "recursive_decomposability",
        "independent_subproblems"
      ]
    },
    "solution": {
      "id": "sol-dac",
      "name": "Divide and Conquer",
      "preconditions": [
        "recursive_decomposability",
        "independent_subproblems"
      ],
      "transformation": {
        "steps": [
          {
            "operation": "decompose",
            "args": {
              "predicate": "recursive_split"
            },
            "binds": "parts",
            "rationale": "Break into smaller instances of the same problem type"
          },
          {
            "operation": "transform",
            "args": {
              "morphism": "solve",
              "condition": "is_base_case"
            },
            "binds": "base_solutions",
            "rationale": "Solve base cases directly"
          },
          {
            "operation": "compose",
            "args": {
              "rule": "merge"
            },
            "binds": "full_solution",
            "rationale": "Combine sub-solutions into complete solution"
          }
        ],
        "composition_type": "sequential"
      },
      "postconditions": [
        {
          "predicate": "whole is in solved state",
          "guarantees": "Solution covers all parts"
        }
      ]
    },
    "instantiations": [
      {
        "domain": "algorithms",
        "concrete_problem": "Sort a list of n elements",
        "concrete_solution": "Merge sort: split in half, sort each, merge sorted halves",
        "mapping_notes": "decompose=split at midpoint, base_case=single element, compose=merge"
      },
      {
        "domain": "mathematics",
        "concrete_problem": "Compute Fourier transform of signal with n samples",
        "concrete_solution": "FFT: decompose into even/odd indices, recurse, combine with twiddle factors",
        "mapping_notes": "decompose=even/odd split, base_case=single point DFT, compose=butterfly"
      },
      {
        "domain": "management",
        "concrete_problem": "Execute large project with many deliverables",
        "concrete_solution": "WBS: decompose into work packages, assign teams, integrate results",
        "mapping_notes": "decompose=WBS, base_case=atomic task, compose=integration"
      },
      {
        "domain": "mathematics",
        "concrete_problem": "Multiply two n-digit numbers",
        "concrete_solution": "Karatsuba: split digits, 3 recursive multiplications instead of 4, combine",
        "mapping_notes": "decompose=split digits, base_case=single digit multiply, compose=shift and add"
      }
    ],
    "related_patterns": [
      "pat-reduction",
      "pat-incremental"
    ],
    "tags": [
      "structural",
      "recursive",
      "parallelizable"
    ]
  },
  {
    "id": "pat-reduction",
    "name": "Reduction to Known Problem",
    "description": "When a hard problem can be transformed into an equivalent problem that we already know how to solve, transform, solve, and map back.",
    "problem": {
      "id": "prob-reduction",
      "name": "Problem Reducible to Known Form",
      "structure": {
        "entities": [
          {
            "id": "problem_A",
            "type": "problem",
            "properties": {
              "difficulty": "hard"
            }
          },
          {
            "id": "problem_B",
            "type": "problem",
            "properties": {
              "difficulty": "easier"
            }
          }
        ],
        "relations": [
          {
            "source": "problem_A",
            "target": "problem_B",
            "type": "maps_to",
            "properties": {
              "preserves": "solution"
            }
          }
        ]
      },
      "constraints": [],
      "goal": {
        "type": "transform",
        "target": "problem_A",
        "predicate": "problem_A is solved"
      },
      "tags": [
        "reducible",
        "has_known_equivalent"
      ]
    },
    "solution": {
      "id": "sol-reduction",
      "name": "Reduction to Known Problem",
      "preconditions": [
        "reducible",
        "has_known_equivalent"
      ],
      "transformation": {
        "steps": [
          {
            "operation": "transform",
            "args": {
              "morphism": "encode"
            },
            "binds": "reduced_form",
            "rationale": "Transform problem into equivalent easier form"
          },
          {
            "operation": "search",
            "args": {
              "predicate": "is_solved"
            },
            "binds": "reduced_solution",
            "rationale": "Solve the easier problem"
          },
          {
            "operation": "transform",
            "args": {
              "morphism": "decode"
            },
            "binds": "original_solution",
            "rationale": "Map solution back to original problem space"
          }
        ],
        "composition_type": "sequential"
      },
      "postconditions": [
        {
          "predicate": "problem_A is solved",
          "guarantees": "If encode/decode are correct and B is solved, A is solved"
        }
      ]
    },
    "instantiations": [
      {
        "domain": "algorithms",
        "concrete_problem": "Find shortest path with negative edge weights",
        "concrete_solution": "Reduce to Bellman-Ford by reweighting edges (Johnson's algorithm)",
        "mapping_notes": "encode=reweight edges, solve=Bellman-Ford, decode=adjust distances"
      },
      {
        "domain": "mathematics",
        "concrete_problem": "Solve differential equation",
        "concrete_solution": "Laplace transform: convert to algebraic equation, solve, inverse transform",
        "mapping_notes": "encode=Laplace transform, solve=algebra, decode=inverse Laplace"
      },
      {
        "domain": "software_engineering",
        "concrete_problem": "Complex data format conversion (A\u2192C)",
        "concrete_solution": "Convert to intermediate canonical form (A\u2192B\u2192C) using existing A\u2192B and B\u2192C converters",
        "mapping_notes": "encode=convert to canonical, solve=identity, decode=convert from canonical"
      },
      {
        "domain": "cryptography",
        "concrete_problem": "Break cipher by finding structure",
        "concrete_solution": "Reduce to known algebraic problem (e.g., discrete log, factoring)",
        "mapping_notes": "encode=algebraic formulation, solve=known algorithm, decode=extract key"
      }
    ],
    "related_patterns": [
      "pat-divide-conquer",
      "pat-dualization"
    ],
    "tags": [
      "transformational",
      "equivalence",
      "mapping"
    ]
  },
  {
    "id": "pat-fixedpoint",
    "name": "Fixed Point Iteration",
    "description": "When you have a transformation that is contractive (brings things closer together), repeatedly applying it will converge to a unique stable point.",
    "problem": {
      "id": "prob-fixedpoint",
      "name": "Convergent Iterative Process",
      "structure": {
        "entities": [
          {
            "id": "state",
            "type": "element",
            "properties": {
              "mutable": true
            }
          },
          {
            "id": "transform",
            "type": "operation",
            "properties": {
              "contractive": true
            }
          }
        ],
        "relations": [
          {
            "source": "transform",
            "target": "state",
            "type": "maps_to",
            "properties": {}
          }
        ]
      },
      "constraints": [
        {
          "predicate": "transform is contractive",
          "over": [
            "transform"
          ],
          "type": "precondition"
        }
      ],
      "goal": {
        "type": "find",
        "target": "state",
        "predicate": "f(state) = state"
      },
      "tags": [
        "iterative",
        "convergent",
        "has_contractive_map"
      ]
    },
    "solution": {
      "id": "sol-fixedpoint",
      "name": "Fixed Point Iteration",
      "preconditions": [
        "iterative",
        "has_contractive_map"
      ],
      "transformation": {
        "steps": [
          {
            "operation": "search",
            "args": {
              "predicate": "initial_guess"
            },
            "binds": "x0",
            "rationale": "Start with an initial approximation"
          },
          {
            "operation": "fix",
            "args": {
              "morphism": "apply_transform_repeatedly"
            },
            "binds": "x_star",
            "rationale": "Iterate x_{n+1} = f(x_n) until convergence"
          }
        ],
        "composition_type": "iterative"
      },
      "postconditions": [
        {
          "predicate": "f(x_star) = x_star",
          "guarantees": "Converges to fixed point if f is contractive"
        }
      ]
    },
    "instantiations": [
      {
        "domain": "mathematics",
        "concrete_problem": "Find root of f(x) = 0",
        "concrete_solution": "Newton's method: x_{n+1} = x_n - f(x_n)/f'(x_n)",
        "mapping_notes": "transform=Newton update, convergence=quadratic near root"
      },
      {
        "domain": "compilers",
        "concrete_problem": "Compute reaching definitions in dataflow analysis",
        "concrete_solution": "Iterate dataflow equations over CFG until no changes",
        "mapping_notes": "transform=transfer functions, convergence=monotone on finite lattice"
      },
      {
        "domain": "machine_learning",
        "concrete_problem": "Train model parameters",
        "concrete_solution": "Gradient descent: \u03b8_{n+1} = \u03b8_n - \u03b1\u2207L(\u03b8_n) until convergence",
        "mapping_notes": "transform=gradient update, convergence=with proper learning rate"
      },
      {
        "domain": "economics",
        "concrete_problem": "Find market equilibrium price",
        "concrete_solution": "Tatonnement: adjust price based on excess demand until supply=demand",
        "mapping_notes": "transform=price adjustment, convergence=under gross substitutability"
      },
      {
        "domain": "software_engineering",
        "concrete_problem": "Resolve dependency versions",
        "concrete_solution": "SAT solver / iterative constraint propagation until consistent assignment",
        "mapping_notes": "transform=propagate constraints, convergence=finite domain"
      }
    ],
    "related_patterns": [
      "pat-reduction",
      "pat-invariance"
    ],
    "tags": [
      "iterative",
      "convergent",
      "numerical"
    ]
  }
]